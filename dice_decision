# Implementing Module 3: chooseDice(Score, LoseCount, WinCount, NDice, M) in decision_making.py

def chooseDice(Score, LoseCount, WinCount, NDice, M):
    """
    Determines the optimal number of dice to roll based on the current score, historical outcomes, and the
    exploration-exploitation trade-off parameter M.

    Parameters:
    - Score (int): The current score of the player.
    - LoseCount (2D list of int): A matrix recording the number of losses for each decision.
    - WinCount (2D list of int): A matrix recording the number of wins for each decision.
    - NDice (int): The maximum number of dice that can be rolled in a turn.
    - M (int): The exploration-exploitation trade-off parameter.

    Returns:
    - int: The optimal number of dice to roll.
    """
    # Initialize variables to store the best choice and its calculated probability
    best_choice = 1
    highest_probability = -1

    for k in range(1, NDice + 1):
        # Calculate fk and pk for each possible choice of dice to roll
        wins = WinCount[Score][k - 1]
        losses = LoseCount[Score][k - 1]
        total = wins + losses

        # Avoid division by zero; if no games played with this score and choice, skip the calculation
        if total == 0:
            continue

        fk = wins / total
        pk = fk + M / (1 + total)

        # Update the best choice if this choice has a higher pk
        if pk > highest_probability:
            highest_probability = pk
            best_choice = k

    return best_choice

# Note: The actual implementation would require proper initialization of WinCount and LoseCount matrices,
# and the values for Score, NDice, and M based on the game configuration.
# This function call is commented out as an example usage.
# print(chooseDice(Score=5, LoseCount=[[0, 2], [1, 3]], WinCount=[[2, 1], [4, 0]], NDice=2, M=100))
